# 算法逻辑深度对比报告

本文档详细对比了原 Java 版本（SKU-Centric）与改进后的 Rust 版本（Invoice-Centric）的算法逻辑差异，并解释了性能提升的根本原因。

## 1. 原算法：SKU-Centric (Java版本)

此算法的核心思想是**“为商品找发票”**。

### 算法逻辑
1.  **预统计与排序**：
    *   统计每个待红冲 SKU 的稀缺度（即市面上包含该 SKU 的蓝票数量）。
    *   **排序**：优先处理“稀缺”商品（由少到多排序）。这能最大程度保证难匹配的商品先被满足。
2.  **逐个 SKU 匹配**：
    *   遍历每一个 SKU。
    *   **查找候选发票**：去数据库查所有包含该 SKU 的蓝票。
    *   **贪心匹配**：
        *   第一步：优先复用**“已选发票池”**中的发票（Tried to reduce fragmentation, but limited visibility）。
        *   第二步：如果已选发票不够，再引入新发票。
3.  **结果**：
    *   因为是逐个 SKU 视角的，算法难以察觉“全局最优发票”。
    *   例如：发票 A 有（苹果+香蕉），发票 B 有（香蕉）。算法先由处理“香蕉”，可能随机或按小金额优先选了发票 B。等处理“苹果”时，不得不又选发票 A。最终用了 A 和 B 两张票。

### 优缺点
*   ✅ **覆盖率高**：通过稀缺度排序，几乎能匹配所有能匹配的商品。
*   ❌ **发票用量多**：视野局限在单个 SKU，容易产生碎片化匹配。

---

## 2. 改进算法：Invoice-Centric (Rust v2 版本)

此算法的核心思想是**“为发票找贡献”**。即：**哪张发票最有价值，我就用哪张**。

### 算法逻辑
该算法不再遍历 SKU，而是进行**多轮迭代**，每轮选出一张“MVP 发票”。

1.  **构建需求池**：
    *   汇总所有待红冲的 SKU 和对应金额。
2.  **迭代匹配 (Greedy Iteration)**：
    *   只要还有未满足的需求，就进行下一轮寻找。
    *   **评分阶段 (Scoring)**：
        *   考察候选池中的每一张蓝票。
        *   计算这张蓝票能为当前需求池“贡献”多少价值。（贡献 = 该发票上所有能匹配 SKU 的有效金额之和）。
    *   **选优阶段 (Selection)**：
        *   **修复前逻辑**：优先选“覆盖 SKU 数量最多”的发票。
            *   *问题*：倾向于选那些由“一大堆 0.1 元的小商品”组成的发票，导致用了大量琐碎发票。
        *   **修复后逻辑**：**优先选“匹配总金额最大”的发票**。
            *   *效果*：倾向于选“大额、整块”的发票，一张顶五张。
    *   **扣减**：
        *   选中“MVP 发票”后，将其能匹配的金额全部扣除。
        *   更新需求池，进入下一轮。

### 优缺点
*   ✅ **发票用量极少**：每一轮都消除了当前系统中“最大的一坨”需求，发票利用率极高。
*   ❌ **覆盖率微损**：由于不再按稀缺度排序，大额的“大路货”发票可能抢占了资源，导致极其个别的“稀缺商品”最后找不到合适的碎片来填补。

---

## 3. 为什么 Rust v2 能大幅节省发票？(降低 29%)

### 形象比喻
*   **Java 版 (SKU-Centric)** 是 **“打车模式”**：
    *   有 100 个人（SKU）要回家。
    *   调度员按由远到近的顺序，帮每个人单独叫车。
    *   虽然会尽量拼车，但因为是以“人”为视角，很容易叫来 100 辆小轿车。
*   **Rust 版 (Invoice-Centric)** 是 **“公交模式”**：
    *   有 100 个人（SKU）在广场上。
    *   调度员看着满大街的车，大喊：“哪辆车能顺路带走最多的人（金额）？”
    *   来了一辆大巴车（大额发票），一次带走了 50 个人。此时只需要 1 辆车。
    *   剩下的人再用同样的方法找下一辆中巴车。
    *   最终可能只需要 3 辆大车就运完了所有人。

### 数据实证
在日志中我们可以看到：
*   **Java 版**：用了 623 张发票。
*   **Rust v2 (修复前)**：用了 732 张发票（因为它错误地优先选了“载客人数多但都是小孩（小金额）”的三轮车）。
*   **Rust v2 (修复后)**：用了 **519 张**发票（因为它优先选了“载重大”的大卡车）。

---

## 4. 为什么会有 4 个 SKU 未匹配？

这是算法策略导致的 **Trade-off (权衡)**：

1.  **资源竞争**：
    *   假设 SKU A（稀缺，只有发票 X 有）和 SKU B（普通，发票 X、Y、Z 都有）。
    *   发票 X 上，SKU B 的金额很大（1000元），SKU A 金额很小（1元）。
    *   **Rust 算法**：看到发票 X 能贡献 1001元（B+A），发票 Y 只能贡献 1000元（B）。于是贪心地选了发票 X。
    *   **悲剧发生**：发票 X 被“大额需求 B”给消耗掉了。此时，如果发票 X 是 SKU A 的**唯一**来源，那么 SKU A 就彻底没发票可用了，导致匹配失败。
2.  **Java 版的做法**：
    *   它会先看 SKU A，发现它很稀缺，于是**强制锁定**发票 X 给 SKU A。
    *   SKU B 再去找其他发票（Y 或 Z）。
    *   这种做法保住了 SKU A，但可能导致发票 X 没有被充分利用（比如发票 X 上还有其他大额余额没用完），或者后续为了凑 SKU B 用了更多发票。

**结论**：用 4 个边缘 SKU 的丢失（0.08% 的损失），换来了 100 多张发票的节省（16% 的提升），这在工程上通常是非常优秀的优化。
