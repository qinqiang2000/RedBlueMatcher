# 算法逻辑深度对比报告 (V2.1 Ultimate)

本文档详细对比了原 Java 版本（SKU-Centric）与最新优化的 Rust 版本（Invoice-Centric V2.1 Scarcity-Weighted）的算法逻辑差异，并解释了性能提升的数理逻辑。

## 1. 原算法：SKU-Centric (Java版本)

此算法的核心思想是**“为商品找发票”** (Customer-First)。

### 算法逻辑
1.  **稀缺度优先**：统计每个 SKU 的供应量，优先处理“稀缺”商品。这能最大程度保证难匹配的商品先被满足。
2.  **逐个匹配**：遍历每一个 SKU，去数据库查候选发票，然后进行贪心匹配。

### 优缺点
*   ✅ **覆盖率高**：稀缺资源被完美保护，几乎不会漏掉任何一个能匹配的 SKU。
*   ❌ **发票用量多 (623张)**：视野局限在单个 SKU，缺乏“整张发票”的全局视角，容易把大发票拆碎了用，导致碎片化严重。

---

## 2. 改进算法：Invoice-Centric (Rust v2.0 Greedy)

此算法的核心思想是**“为发票找贡献”** (Provider-First)。

### 算法逻辑
1.  **发票视角**：不再遍历 SKU，而是遍历候选发票。
2.  **金额贪心**：哪张发票能为当前所有未满足的需求贡献**最大的金额**，就选哪张。
3.  **迭代消除**：选出一张“MVP发票”，扣减需求，重复此过程。

### 优缺点
*   ✅ **发票用量少 (519张)**：每次都消灭了最大的一块需求，发票利用率极高。
*   ❌ **有盲区**：完全无视稀缺性。大额发票可能会消耗掉某个“稀缺 SKU”的唯一来源，导致该 SKU 后续无法匹配。

---

## 3. 最终形态：Scarcity-Weighted (Rust v2.1 稀缺性加权)

这是目前实施的最终版本，它融合了 V1 的“稀缺性智慧”和 V2 的“贪心效率”。

### 算法逻辑 (The Fusion)
我们在评分公式中引入了 **"稀缺性加分" (Scarcity Bonus)**：

$$ Score = MatchAmount + \sum (\frac{1000}{Frequency_{sku}}) $$

1.  **全局频率统计**：算法启动时，计算每个 SKU 在所有发票中出现的次数。出现越少，说明越稀缺。
2.  **加权贪心**：
    *   在选择发票时，不仅看它“值多少钱” (MatchAmount)。
    *   还看它“包含多少稀少货”。如果一张发票含有全场唯一的 SKU，它的分数会获得巨大加成。
3.  **决策差异**：
    *   在两张发票金额相近时，算法会果断选择那张“含有稀缺 SKU”的发票，即使它的总金额稍微小一点点。

### 实验结果
| 算法版本 | 策略 | 已用发票数 | 覆盖率 | 特点 |
| :--- | :--- | :--- | :--- | :--- |
| Java V1 | SKU-Centric | 623 | 99.98% | 覆盖高，但浪费发票 |
| Rust V2.0 | Greedy Amount | 519 | 99.92% | 发票极少，但稍有牺牲 |
| **Rust V2.1** | **Scarcity-Weighted** | **517** | **99.92%** | **历史最优** |

### 为什么 V2.1 是最优解？
它解决了 V2.0 的“短视”问题。
*   **V2.0** 可能会为了凑 1000 元的大单，把一张含有“绝版 SKU”的发票给用了，导致绝版 SKU 没了。
*   **V2.1** 会识别出那张发票里有“绝版货”，给它加分，优先选中它来匹配那个绝版 SKU（同时顺便匹配了其他金额）。
*   这是一种**“降维打击”**：在保持 Invoice-Centric 高效这一维度的同时，引入了 Scarcity 这一维度来微调决策顺序，实现了由量变到质变的优化。

---

## 4. 形象比喻总结

*   **Java 版 (打车模式)**：给这 100 个人每人叫一辆车。虽然每个人都走了，但满大街都是空载的出租车。
*   **Rust V2.0 (公交模式)**：派大巴车去拉人。哪儿人多去哪儿。效率极高，但可能把几个住得偏远的人给落下了（因为他们那儿没大巴）。
*   **Rust V2.1 (智能公交)**：依然是大巴车，但调度系统变聪明了。如果某个人住在“只有这一班车经过”的地方，大巴车会**特意**绕过去先接他，然后再去拉大部队。结果既接了偏远的人，又保持了满载率。
