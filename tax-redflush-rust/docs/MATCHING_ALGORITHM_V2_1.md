# 红冲蓝票匹配算法规范 (V2.1 Scarcity-Weighted)

**版本**: V2.1 (2025-12-18)
**核心思想**: 发票中心 (Invoice-Centric) + 稀缺性加权 (Scarcity-Weighted Greedy)
**目标**: 在保证覆盖率的前提下，最小化使用的蓝票数量。

本文档旨在提供一个语言无关的算法规范，任何编程语言（Python/Java/Go/C++）均可参照此文档复刻该算法。

---

## 1. 核心概念与数据结构

### 1.1 输入数据
*   **待匹配单据 (Bill)**: 包含一组 SKU 及其负数金额（需求）。
    *   `Map<SkuCode, RequiredAmount>`: Key为SKU编码，Value为绝对值金额。
*   **候选发票池 (Candidate Invoices)**: 包含一组蓝票，每张蓝票包含多个明细。
    *   `Invoice`: `{ ID, List<Item> }`
    *   `Item`: `{ SkuCode, Amount, RemainingAmount }`

### 1.2 运行时状态
*   **倒排索引 (Inverted Index)**: `Map<SkuCode, Set<InvoiceID>>`
    *   用于快速查找包含特定 SKU 的所有发票。
*   **全局频率表 (Global Frequency Map)**: `Map<SkuCode, Integer>`
    *   统计每个 SKU 在所有候选发票中出现的总次数 (Document Frequency)。
    *   **用途**: 计算稀缺性。出现次数越少，越稀缺。
*   **需求跟踪器 (Requirements Tracker)**:
    *   实时维护当前还差多少金额没匹配。

---

## 2. 算法流程 (Algorithm Flow)

### 阶段 1: 预处理 (Phase 1: Preprocessing)

1.  **加载数据**:
    *   加载待匹配单据明细。
    *   加载所有相关的候选发票明细。
2.  **数据清洗 (Data Cleaning)**:
    *   对所有 SKU 编码执行 `trim()` 去除首尾空格。
    *   **过滤**: 如果 SKU 为空字符串，直接丢弃，不参与匹配。
3.  **索引构建**:
    *   遍历所有候选发票明细。
    *   构建 **倒排索引**。
    *   构建 **全局频率表** (`sku_frequency_map`)。
        *   注意：同一张发票内如果有重复 SKU，只计一次频率（Document Frequency）。

### 阶段 2: 迭代匹配 (Phase 2: Iterative Matching)

这是一个贪心迭代过程。只要需求未满足，就不断循环。

**伪代码 (Pseudocode)**:

```python
while not requirements.is_satisfied():
    best_invoice = None
    max_score = -1
    
    # 1. 确定搜索范围：只搜索那些包含“当前所需SKU”的发票
    candidate_invoices = get_candidates_from_index(requirements.needed_skus)
    
    # 2. 评分选优 (Scoring)
    for invoice in candidate_invoices:
        score = calculate_score(invoice, requirements, frequency_map)
        
        if score > max_score:
            max_score = score
            best_invoice = invoice
        # Tie-breaker: 如果分数相同，优先选覆盖SKU数量更多的
        elif score == max_score and invoice.sku_count > best_invoice.sku_count:
            best_invoice = invoice
            
    # 3. 终止条件
    if best_invoice is None:
        break (无法继续匹配，部分SKU未满足)
        
    # 4. 消费与扣减 (Consume)
    consume(best_invoice, requirements)
```

### 阶段 3: 评分逻辑 (Scoring Logic) - **核心**

如何评价一张发票的价值？这是 V2.1 的精髓。

$$ Score = MatchAmount + ScarcityScore $$

对于一张候选发票：
1.  **MatchAmount (基础分)**:
    *   该发票上所有能匹配当前需求的 SKU 的**有效金额**之和。
    *   `EffectiveAmount = min(InvoiceItem.Remaining, Requirement.Remaining)`
2.  **ScarcityScore (稀缺性加分)**:
    *   遍历该发票上所有能匹配需求的 SKU。
    *   `Frequency = frequency_map.get(sku)`
    *   $$ Bonus = \frac{1000}{Frequency} $$ (可调整权重，建议 1000)
    *   `ScarcityScore = Sum(Bonus)`
    *   **原理**: 如果一个 SKU 很稀缺（Freq=1），它会贡献 1000 分。这相当于给这张发票“虚拟”增加了 1000 元的价值，使其在与同等金额的普通发票竞争时胜出。

### 阶段 4: 消费逻辑 (Consumption)

选中最佳发票后：
1.  遍历发票中的有效明细。
2.  **扣减需求**: `Requirement.Remaining -= MatchAmount`
3.  **扣减发票**: `InvoiceItem.Remaining -= MatchAmount`
    *   注意：发票可以**部分使用**。剩余金额可供后续单据使用（如果是在批量匹配场景下）。但在单次单据匹配中，通常发票状态是临时的，或者标记该发票已被使用。
    *   **V2.1 策略**: 我们统计“已用发票数”。只要发票被选中过一次并扣减了金额，它就计入 Used Set。

---

## 3. 实现细节与边界情况

1.  **浮点数精度**:
    *   涉及金额计算，**必须**使用高精度类型（如 Java `BigDecimal`, Python `Decimal`, Rust `BigDecimal`）。**严禁**使用 `double/float`。
2.  **零值处理**:
    *   发票金额或需求金额 <= 0 的明细应被忽略。
3.  **循环依赖/死锁**:
    *   由于是贪心算法，不存在死锁。
    *   最大迭代次数理论上等于 SKU 数量（最坏情况每次只匹配一个 SKU），但通常远小于此。可设置安全断路器（如 max_iterations = 5000）。
4.  **未匹配报告**:
    *   算法结束时，如果 `requirements` 不为空，必须输出未匹配的 SKU 明细及缺口金额。

## 4. 性能指标 (Reference)

*   **时间复杂度**: $O(K \cdot N)$，其中 K 是发票总数，N 是 SKU 总数。通过倒排索引优化后，实际性能极快。
*   **基准战绩**:
    *   环境: Rust, PostgreSQL
    *   数据量: 4800+ SKU, 30000+ 候选发票 (1626万条明细 / 16.2M Items)
    *   耗时: 数据加载 ~18s, 算法计算 ~197s (3.3分钟)
    *   发票使用量: 516 张 (最新运行结果 516 张，因空SKU过滤导致略有不同)

---
*Generated by Antigravity Agent - 2025-12-18*
