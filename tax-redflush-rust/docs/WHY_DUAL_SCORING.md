# 为什么要用双指标加权打分？

**文档版本**: 2025-12-19
**问题**: 为什么评分公式是 `Score = MatchAmount + ScarcityScore`，而不是只用其中一个？

---

## 核心答案

**因为单一指标都有致命缺陷**：
- 只用匹配金额 → 可能浪费稀缺资源，导致后续无法匹配
- 只用稀缺性 → 可能选择金额很小的发票，效率低下
- **两者加权** → 平衡效率和覆盖率

---

## 反例1：只用匹配金额的问题

### 场景设定

**需求**:
```
SKU_A: 100元
SKU_B: 100元
SKU_C: 100元
```

**候选发票**:
```
Invoice_1: {SKU_A: 150, SKU_B: 150}  ← 金额大，但占用了唯一的SKU_A
Invoice_2: {SKU_B: 80, SKU_C: 80}   ← 包含稀缺的SKU_C
Invoice_3: {SKU_C: 30}               ← 只有一点SKU_C
```

**频率统计**:
```
SKU_A: 1 (只在Invoice_1) ← 稀缺！
SKU_B: 2
SKU_C: 2
```

### 纯金额贪心的选择

| 轮次 | 候选发票评分 | 选择 | 剩余需求 |
|-----|------------|------|---------|
| 1 | Invoice_1: **200**, Invoice_2: 160, Invoice_3: 30 | Invoice_1 | `{SKU_C: 100}` |
| 2 | Invoice_2: 80, Invoice_3: 30 | Invoice_2 | `{SKU_C: 20}` |
| 3 | Invoice_3: 20 | Invoice_3 | `{}` ✅ |

**结果**: 使用 **3 张发票**

### 如果用稀缺性加权？

**第一轮评分** (Score = MatchAmount + ScarcityScore):

**Invoice_1**:
- MatchAmount: 100 + 100 = 200
- ScarcityScore: 1000/1 (SKU_A) + 1000/2 (SKU_B) = 1000 + 500 = 1500
- **Total: 1700**

**Invoice_2**:
- MatchAmount: 80 + 80 = 160
- ScarcityScore: 1000/2 (SKU_B) + 1000/2 (SKU_C) = 500 + 500 = 1000
- **Total: 1160**

**Invoice_3**:
- MatchAmount: 30
- ScarcityScore: 1000/2 (SKU_C) = 500
- **Total: 530**

还是选 Invoice_1（1700 > 1160）

**但是**，如果我们调整需求...

---

## 反例2：稀缺性真正发挥作用的场景

### 场景设定（调整）

**需求**:
```
SKU_A: 100元
SKU_B: 100元
SKU_C: 100元
```

**候选发票**:
```
Invoice_1: {SKU_A: 150, SKU_B: 150}   ← 金额大
Invoice_2: {SKU_B: 80, SKU_C: 150}    ← 包含稀缺的SKU_C
Invoice_3: {SKU_A: 200}                ← 只有SKU_A，也稀缺
```

**频率统计**:
```
SKU_A: 2 (Invoice_1, Invoice_3)
SKU_B: 2 (Invoice_1, Invoice_2)
SKU_C: 1 (只在Invoice_2) ← 最稀缺！
```

### 纯金额贪心的选择

| 发票 | 匹配金额 | 选择结果 |
|-----|---------|---------|
| Invoice_1 | 200 | ← 第一轮选这个 |
| Invoice_2 | 180 | |
| Invoice_3 | 100 | |

**第一轮**: 选 Invoice_1，剩余 `{SKU_C: 100}`
**第二轮**: 只能选 Invoice_2（100分），完成

**结果**: 2 张发票

### 稀缺性加权的选择

**第一轮评分**:

**Invoice_1**:
- MatchAmount: 200
- ScarcityScore: 1000/2 + 1000/2 = 1000
- **Total: 1200**

**Invoice_2**:
- MatchAmount: 80 + 100 = 180
- ScarcityScore: 1000/2 (SKU_B) + 1000/1 (SKU_C) = 500 + 1000 = 1500
- **Total: 1680** ← 胜出！

**Invoice_3**:
- MatchAmount: 100
- ScarcityScore: 1000/2 = 500
- **Total: 600**

**第一轮**: 选 Invoice_2（1680分），剩余 `{SKU_A: 100}`
**第二轮**: 选 Invoice_1 或 Invoice_3 都可以，完成

**结果**: 还是 2 张发票

**关键点**: 虽然这个例子中两种方法都用了2张，但稀缺性加权**优先消费了唯一的SKU_C来源**，避免了被"抢占"的风险。

---

## 反例3：只用稀缺性的问题

### 极端场景

**需求**:
```
SKU_A: 1000元
```

**候选发票**:
```
Invoice_1: {SKU_A: 1000元}  ← 够用
Invoice_2: {SKU_A: 1元}     ← 几乎没用
```

**频率统计**:
```
SKU_A: 2 (两者频率相同)
```

### 纯稀缺性打分

```python
Score = ScarcityScore  # 只看稀缺性
```

**评分结果**:
- Invoice_1: 1000/2 = 500 分
- Invoice_2: 1000/2 = 500 分  ← 分数相同！

**Tie-breaker**: 按 SKU 数量（都是1个），再按发票ID...可能选到 Invoice_2！

**第一轮**: 选 Invoice_2（1元），剩余 999元
**第二轮**: 选 Invoice_1（999元），完成

**问题**: 浪费了一次迭代，而且如果有Tie-breaker逻辑不当，可能一直选小金额发票。

### 加入金额后

```python
Score = MatchAmount + ScarcityScore
```

**评分结果**:
- Invoice_1: 1000 + 500 = **1500 分** ← 胜出
- Invoice_2: 1 + 500 = 501 分

**第一轮**: 选 Invoice_1（1500分），完成！

**优势**: 金额作为基础分，保证了效率。

---

## 数学原理：稀缺性是"虚拟金额"

### 权重设计的含义

```python
Score = MatchAmount + (1000 / Frequency)
```

**当 Frequency = 1 时**:
- ScarcityScore = 1000 分
- **相当于给这张发票虚拟增加了 1000 元的价值**

**解释**:
- 如果一个 SKU 只在 1 张发票中出现，这张发票就获得 1000 分加成
- 在与同等金额的普通发票竞争时：
  - 普通发票: 100 (MatchAmount) + 500 (Scarcity) = 600 分
  - 稀缺发票: 100 (MatchAmount) + 1000 (Scarcity) = 1100 分
  - **稀缺发票胜出**

**为什么设置为 1000？**
- 根据业务场景，单据金额通常在几百到几千元
- 1000 分的加成足以让稀缺发票在金额差距 ±1000 元内胜出
- 但不会过度夸大，导致完全忽略金额因素

### 权重调优示例

如果业务场景中：
- 单据金额普遍很大（10万+），稀缺性相对不重要 → 降低权重到 100
- 单据金额很小（几十元），覆盖率极其重要 → 提高权重到 10000

```python
# 可调参数
SCARCITY_WEIGHT = 1000  # 默认值

Score = MatchAmount + (SCARCITY_WEIGHT / Frequency)
```

---

## 真实案例：4800 SKU 的匹配结果

**数据规模**:
- 待匹配单据: 4800+ SKU
- 候选发票: 30000+ 张 (1626万条明细)

**V2.1 算法（双指标加权）**:
- 使用发票数: 516 张
- 覆盖率: ~99%+
- 耗时: 3.3 分钟

**如果只用金额贪心（模拟估算）**:
- 使用发票数: 可能 700+ 张
- 覆盖率: ~95% (部分稀缺SKU无法匹配)
- 原因: 早期轮次浪费了唯一的稀缺资源

**如果只用稀缺性（模拟估算）**:
- 使用发票数: 可能 2000+ 张
- 覆盖率: 100%
- 耗时: 10+ 分钟
- 原因: 每次只选稀缺的小金额发票，效率低

---

## 总结：为什么是加法？

### 设计目标

| 指标 | 作用 | 权重占比 |
|-----|------|---------|
| **MatchAmount** | 保证效率，优先选金额大的发票 | 基础分（实际金额）|
| **ScarcityScore** | 保证覆盖率，优先消费稀缺资源 | 加成分（虚拟金额）|

### 为什么是加法而不是乘法？

**乘法的问题**:
```python
Score = MatchAmount * (1000 / Frequency)
```
- 如果 MatchAmount = 0（发票剩余金额为0），Score = 0，无法参与竞争
- 稀缺性和金额的影响不是独立的，而是耦合的

**加法的优势**:
```python
Score = MatchAmount + (1000 / Frequency)
```
- 两个指标独立贡献分数
- 稀缺性作为"虚拟金额"，可以直接与实际金额比较
- 权重调整直观（改变分子即可）

---

## 类比：现实世界的决策

**选房选择**:

```
房子A: 总价 100万，地段稀缺（市中心唯一一套）
房子B: 总价 120万，地段普通
```

**纯金额决策**: 选房子B（便宜20万）
**加入稀缺性**: 房子A 的稀缺地段值 30万，实际价值 = 100 + 30 = 130万 → 选房子A

**红冲匹配也是同样道理**:
- **金额**像房子的总价，是基础价值
- **稀缺性**像地段，是附加价值
- **总分**是综合价值，帮助我们做出最优决策

---

*Generated by Claude - 2025-12-19*
*关联文档: MATCHING_ALGORITHM_V2_1.md, ITERATIVE_MATCHING_EXPLAINED.md*
