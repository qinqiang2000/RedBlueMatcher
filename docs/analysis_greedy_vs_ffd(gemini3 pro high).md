# 贪心算法(Greedy)与FFD算法对比分析报告

## 1. 核心结论：为什么 FFD 完胜？

**一句话总结**：**FFD (First Fit Decreasing)** 算法就像“**先装大石头，再装沙子**”，而 **Greedy (贪心)** 算法则是“**拿到什么装什么**”。

在 Prod 环境中，**Greedy** 算法因为没有对负数发票进行排序，导致许多零散的“小额负数”提前占用了“大额蓝票”的空间（也就是**碎片化**）。等到“大额负数”进场时，已经找不到一张完整的、足够大的蓝票来覆盖它了，只能被迫拆分，去凑几十张甚至上百张零散的蓝票余额。

**每一次拆分，都意味着要多开一张红票。** 这就是为什么 Greedy 算法需要开具 23,723 张红票，而 FFD 只需要 3,586 张（相差近 7 倍）的根本原因。

---

## 2. 形象比喻：停车场的故事

想象你需要把不同大小的车（负数发票）停进停车场（蓝票）。

- **大巴车** = 大额负数发票（极易被拆分）
- **摩托车** = 小额负数发票
- **超长停车位** = 大额蓝票（资源稀缺）

### 场景 A：Greedy 算法（随缘停车）
车队来了，顺序是乱的：摩托车、摩托车、大巴车、摩托车……

1. **摩托车来了**：管理员看了一眼，发现全是空车位，为了省事，让摩托车停进了**超长停车位**的最里面。
2. **又来几辆摩托车**：又占了几个超长停车位。
3. **大巴车来了**：管理员傻眼了。现有的超长停车位里，每个都停了一辆小摩托车，**由于位置被占用，大巴车停不进去了！**
4. **被迫拆分**：没办法，管理员只能把大巴车“锯开”（比喻拆分金额），车头停这个位，车身停那个位，车尾停另一个位。
   
**结果**：停一辆大巴车，占用了 5 个停车位（对应开了 5 张红票）。

### 场景 B：FFD 算法（先大后小）
FFD 管理员很聪明，他先把车队排了个序：大巴车在前，摩托车在后。

1. **大巴车先来**：管理员直接把它引导进全是空的**超长停车位**。刚刚好，利用率 100%。
2. **摩托车后来**：管理员让它们去填补大巴车剩下的缝隙，或者停在普通的车位里。

**结果**：停一辆大巴车，只占用了 1 个停车位（对应开了 1 张红票）。

---

## 3. 深度技术解析

### 3.1 数据处理顺序的致命差异

| 特性 | Greedy (贪心) | FFD (First Fit Decreasing) |
| :--- | :--- | :--- |
| **处理顺序** | **随机/入库顺序** (不做排序) | **降序排列** (处理大额负数优先) |
| **匹配逻辑** | 优先找精确匹配，找不到就**用最大的蓝票** | 优先找**第一个能装下**的蓝票 |
| **主要缺陷** | **小票吃大票**：小负数蚕食大蓝票的余额 | 需要预先排序 (开销极小) |
| **碎片化程度**| **高** | **低** |

从代码中可以看到：
- **FFD (`strategies/ffd.py`)**: 明确调用了 `sorted(negatives, key=..., reverse=True)`，保证大额先行。
- **Greedy (`strategies/greedy_large.py`)**: 直接按数据库读取顺序（通常是 ID 顺序）处理。

### 3.2 为什么 Prod 环境差异巨大？

PROD 环境的数据通常具有**长尾分布**特征：
1. 存在**超大额**的负数单据（比如整单退货）。
2. 存在**超大额**的蓝票（比如合并开票）。

在 Greedy 策略下，那些超大额的蓝票极易被随机到来的小额负数“啃”一口。一旦不再完整，当那个超大额的负数到来时，就必须**跨越**多张蓝票进行红冲。

> **公式**：需要的红票数量 = 涉及的蓝票数量。
> 如果一张 100万 的负数单据，能匹配到一张 100万 的蓝票，红票数 = 1。
> 如果那张 100万 的蓝票先被扣了 10元，剩 999,990。
> 100万 的负数单据来了，这张票不够了！它得吃掉这张票，还要再去找第二张票。
> **结果红票数由 1 变成了 2（甚至更多）。**

### 3.3 本地环境为何差异不大？

本地环境的数据量较小（仅 6000 张），且可能**数据分布较均匀**（大额单据少，或者大小单据比例没有 Prod 那么悬殊）。在这种情况下，“碎片化”带来的惩罚不明显，Greedy 偶尔还能因为碰巧的精确匹配（Exact Match）占点优势。

## 4. 为什么“本地环境”的数据反直觉？

**用户疑问**：“本地负数单据才 450 张，Prod 有 16万张，为什么本地反而要开更多红票（6189 vs 3586）？”

**答案：看金额，不要看张数。**

通过分析日志，我们发现：

| 指标 | 本地环境 (Local) | 生产环境 (Prod) | 对比 |
| :--- | :--- | :--- | :--- |
| **负数单据数** | 450 张 | 168,557 张 | Prod 是 Local 的 374 倍 |
| **负数明细行数** | 671,385 行 | 325,729 行 | **Local 是 Prod 的 2 倍** |
| **需要红冲总金额** | **2,676 万** (26.7M) | **1,182 万** (11.8M) | **Local 是 Prod 的 2.26 倍** |
| **需要红票数(FFD)** | **6,189 张** | **3,586 张** | **Local 是 Prod 的 1.72 倍** |

**核心原因**：
1. **单据体量不同**：本地那 450 张负数单据是“巨无霸”，平均每张包含 **1500 行**明细，总金额巨大。Prod 的单据是“小蚂蚁”，平均每张仅 2 行。
2. **红票对应的是蓝票**：红票的数量取决于**有多少蓝票被扣减了**。
3. **金额决定蓝票消耗量**：本地环境需要退 **2600多万** 的款，自然比只退 **1100多万** 的 Prod 环境消耗更多蓝票。

**结论**：本地环境红票多，纯粹是因为**涉及的总金额更多**，与“单据张数”无关。算法运作完全正常。

---

## 5. 建议

**坚定使用 FFD 算法。**

在发票红冲这种“装箱问题”场景下，资源（蓝票）是有限且珍贵的。**“先处理大石头”是数学上证明的最优近似解法之一**，它能最大程度地保证大额蓝票的完整性，从而显著降低红票开具数量，减少税务风险和工作量。
